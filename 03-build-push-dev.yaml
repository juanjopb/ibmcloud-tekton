apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  annotations:
    app.openshift.io/description: Executes logic to build, tag and push a container
      image using the intermediate sha tag to the image-url
    app.openshift.io/vcs-ref: master
    app.openshift.io/vcs-uri: https://github.com/IBM/ibm-garage-tekton-tasks
    description: Executes logic to build, tag and push a container image using the
      intermediate sha tag to the image-url
  name: ibm-build-tag-push-dev-v2-0-1
  namespace: dev-freelancer
spec:
  params:
  - name: git-url
    type: string
  - default: master
    name: git-revision
    type: string
  - default: /source
    name: source-dir
    type: string
  - default: ""
    name: image-server
    type: string
  - default: ""
    name: image-namespace
    type: string
  - default: ""
    name: image-repository
    type: string
  - default: ""
    name: image-tag
    type: string
  - default: ""
    name: image-release
    type: string    
  - default: quay.io/buildah/stable:v1.15.0
    name: BUILDER_IMAGE
    type: string
  - default: ./Dockerfile
    name: DOCKERFILE
    type: string
  - default: .
    name: CONTEXT
    type: string
  - default: "false"
    name: TLSVERIFY
    type: string
  - default: docker
    name: FORMAT
    type: string
  - default: overlay
    description: Set buildah storage driver
    name: STORAGE_DRIVER
    type: string
  stepTemplate:
    name: ""
    resources: {}
    volumeMounts:
    - mountPath: $(params.source-dir)
      name: source
  steps:
  - env:
    - name: GIT_PASSWORD
      valueFrom:
        secretKeyRef:
          key: password
          name: git-credentials
          optional: true
    - name: GIT_USERNAME
      valueFrom:
        secretKeyRef:
          key: username
          name: git-credentials
          optional: true
    image: alpine/git
    name: git-clone
    resources: {}
    script: |
      set +x
      if [[ -n "${GIT_USERNAME}" ]] && [[ -n "${GIT_PASSWORD}" ]]; then
          git clone "https://${GIT_USERNAME}:${GIT_PASSWORD}@$(echo $(params.git-url) | awk -F 'https://' '{print $2}')" $(params.source-dir)
      else
          set -x
          git clone $(params.git-url) $(params.source-dir)
      fi
      set -x
      cd $(params.source-dir)
      git checkout $(params.git-revision)
  - env:
    - name: REGISTRY_USER
      valueFrom:
        secretKeyRef:
          key: REGISTRY_USER
          name: ibmcloud-apikey
          optional: true
    - name: REGISTRY_PASSWORD
      valueFrom:
        secretKeyRef:
          key: APIKEY
          name: ibmcloud-apikey
          optional: true
    - name: IBM_CLOUD_APIKEY
      valueFrom:
        secretKeyRef:
          key: APIKEY
          name: ibmcloud-apikey
          optional: true
    - name: IBM_CLOUD_REGION
      valueFrom:
        configMapKeyRef:
          name: ibmcloud-config
          key: REGION
          optional: true          
    image: $(params.BUILDER_IMAGE)
    name: build
    resources: {}
    script: |
      #!/bin/bash
      KEY_NAME=signsample
      yum install skopeo jq -y
      curl -fsSL https://clis.cloud.ibm.com/install/linux | sh
      ibmcloud plugin install key-protect -r "IBM Cloud"
      ibmcloud login --apikey ${IBM_CLOUD_APIKEY} -r ${IBM_CLOUD_REGION}
      ibmcloud target -r ${IBM_CLOUD_REGION} -g appdev-cloud-native
      ##ibmcloud target -r ${IBM_CLOUD_REGION}
      SERVICE_CREATED=$(ibmcloud resource service-instances | grep ${KEY_NAME}-srv || true)
      if [ -z "${SERVICE_CREATED}" ]; then 
        ibmcloud resource service-instance-create ${KEY_NAME}-srv kms tiered-pricing ${IBM_CLOUD_REGION}
      else 
        echo "Service Already Created"
      fi
      SERVICE_INSTANCE=$(ibmcloud resource service-instance ${KEY_NAME}-srv --id | grep "::" | awk {'print $2'})
      echo "List Keys created "
      ibmcloud kp keys --instance-id ${SERVICE_INSTANCE}
      PRIVATE_KEY=$(ibmcloud kp keys --instance-id ${SERVICE_INSTANCE} | grep "kp-${KEY_NAME}-private" | awk {'print $1'} || true )
      PUBLIC_KEY=$(ibmcloud kp keys --instance-id ${SERVICE_INSTANCE} | grep "kp-${KEY_NAME}-public" | awk {'print $1'} || true )
      ##ibmcloud kp create test-${KEY_NAME}-srv --instance-id ${SERVICE_INSTANCE}
      ##ADMIN_TOKEN=$(ibmcloud iam oauth-tokens | grep IAM | awk '{print($4)}')
      ##curl -X GET "https://${IBM_CLOUD_REGION}.kms.cloud.ibm.com/api/v2/keys" -H "accept: application/vnd.ibm.collection+json" -H "authorization: Bearer ${ADMIN_TOKEN}" \ -H "bluemix-instance: ${SERVICE_INSTANCE}"
      
      if [ -z "${PRIVATE_KEY}" ] && [ -z "${PUBLIC_KEY}" ] ; then 
        echo "Creating Keys"
        mkdir user_keys; cd user_keys
        openssl genrsa --out ${KEY_NAME}Private.pem
        openssl rsa -in ${KEY_NAME}Private.pem -pubout -out ${KEY_NAME}Pub.pem
        openssl enc -base64 -A -in ${KEY_NAME}Private.pem -out ${KEY_NAME}Private.b64
        openssl enc -base64 -A -in ${KEY_NAME}Pub.pem -out ${KEY_NAME}Pub.b64
        cat ${KEY_NAME}Pub.pem; cd ..
        ibmcloud kp key create kp-${KEY_NAME}-private -i ${SERVICE_INSTANCE}
        ibmcloud kp key create kp-${KEY_NAME}-public -i ${SERVICE_INSTANCE}
        PRIVATE_KEY=$(ibmcloud kp keys --instance-id ${SERVICE_INSTANCE} | grep "kp-${KEY_NAME}-private" | awk {'print $1'} || true )
        PUBLIC_KEY=$(ibmcloud kp keys --instance-id ${SERVICE_INSTANCE} | grep "kp-${KEY_NAME}-public" | awk {'print $1'} || true )
        PRIVATE_WRAP=$(ibmcloud kp key wrap ${PRIVATE_KEY} --instance-id ${SERVICE_INSTANCE} -p "$(cat ${KEY_NAME}Private.b64)" -output json | jq -r '.["Ciphertext"]')
        PUBLIC_WRAP=$(ibmcloud kp key wrap ${PUBLIC_KEY} --instance-id ${SERVICE_INSTANCE} -p "$(cat ${KEY_NAME}Pub.b64)" -output json | jq -r '.["Ciphertext"]')
      else 
        echo "Keys Already Exists, Retriving the information"
        PRIVATE_B64=$(ibmcloud kp key unwrap ${PRIVATE_KEY} --instance-id ${SERVICE_INSTANCE} ${PRIVATE_WRAP} --output json | jq -r '.["Plaintext"]')
        PUBLIC_B64=$(ibmcloud kp key unwrap ${PUBLIC_KEY} --instance-id ${SERVICE_INSTANCE} ${PUBLIC_WRAP} --output json | jq -r '.["Plaintext"]')
        openssl enc -base64 -A -d -in ${PRIVATE_B64} -out ${KEY_NAME}Private.pem
        openssl enc -base64 -A -d -in ${PUBLIC_B64} -out ${KEY_NAME}Pub.pem
      fi
      ibmcloud kp keys --instance-id ${SERVICE_INSTANCE}

      APP_IMAGE="$(params.image-server)/$(params.image-namespace)/$(params.image-repository):$(params.image-tag)"
      #APP_RELEASE="$(params.image-release)"
      #NAME_IMAGE="$(params.image-repository):$(params.image-tag)"
      buildah --layers --storage-driver=$(params.STORAGE_DRIVER) bud --format=$(params.FORMAT) --tls-verify=$(params.TLSVERIFY) -f $(params.DOCKERFILE) -t ${APP_IMAGE} $(params.CONTEXT)
      set +x
      if [[ -n "${REGISTRY_USER}" ]] && [[ -n "${REGISTRY_PASSWORD}" ]] && [[ "$(params.image-server)" != "image-registry.openshift-image-registry.svc:5000"  ]]; then
        buildah login -u "${REGISTRY_USER}" -p "${REGISTRY_PASSWORD}" "$(params.image-server)"
        echo "buildah login -u "${REGISTRY_USER}" -p "xxxxx" "$(params.image-server)""
      fi
      set -x
      cat ./user_keys/${KEY_NAME}Pub.pem
      buildah --storage-driver=$(params.STORAGE_DRIVER) push --encryption-key jwe:./user_keys/${KEY_NAME}Pub.pem --tls-verify=$(params.TLSVERIFY) --digestfile ./image-digest ${APP_IMAGE} docker://${APP_IMAGE}
      #echo "Delete Image"
      #buildah rmi -f ${APP_IMAGE}
      echo "Pull Image without key"
      buildah pull ${APP_IMAGE} || true
      echo "Pull Image with key"
      buildah pull --decryption-key ./user_keys/${KEY_NAME}Private.pem ${APP_IMAGE}
      skopeo inspect --tls-verify=false docker://${APP_IMAGE}
      
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /var/lib/containers
      name: varlibcontainers
    workingDir: $(params.source-dir)
  volumes:
  - emptyDir: {}
    name: varlibcontainers
  - emptyDir: {}
    name: source